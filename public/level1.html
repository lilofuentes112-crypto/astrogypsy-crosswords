<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Zertifikats-Kreuzworträtsel – Level 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-dark: #000000;
      --copper: #bf8c60;
      --copper-light: #f0c8a0;
      --grid-line: #bf8c60;
      --text-main: #f5e7d8;
      --error: #ff6666;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      background: #000;
      color: var(--text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .cw-wrapper {
      margin: 24px 8px;
      border: 2px solid var(--copper);
      padding: 16px;
      max-width: 900px;
      width: 100%;
      background: #000;
    }

    h1 {
      text-align: center;
      font-size: 20px;
      margin: 0 0 12px;
      color: var(--copper-light);
    }

    .cw-top-bar {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .cw-toggle {
      border: 1px solid var(--copper);
      background: transparent;
      color: var(--copper-light);
      padding: 4px 10px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 3px;
    }

    .cw-toggle.active {
      background: var(--copper);
      color: #000;
    }

    .cw-board-wrapper {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }

    .cw-board {
      position: relative;
      width: 100%;
      max-width: 480px;
      aspect-ratio: 1 / 1; /* Quadrat */
      border: 2px solid var(--copper);
      overflow: hidden;
    }

    .cw-bg {
      position: absolute;
      inset: 0;
      background-image: url("https://static.wixstatic.com/media/6d3632_8671621dade74457977217105254aadf~mv2.png");
      background-size: cover;
      background-position: center;
      opacity: 0.75;
      pointer-events: none;
      z-index: 0;
    }

    .cw-grid {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: repeat(17, 1fr);
      grid-template-rows: repeat(17, 1fr);
      z-index: 1;
    }

    .cw-cell {
      position: relative;
      border: 1px solid rgba(191, 140, 96, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.35);
    }

    .cw-cell.empty {
      border: none;
      background: transparent;
    }

    .cw-number {
      position: absolute;
      top: 1px;
      left: 2px;
      font-size: 9px;
      color: var(--copper-light);
      pointer-events: none;
    }

    .cw-input {
      width: 90%;
      height: 90%;
      border: 1px solid rgba(191, 140, 96, 0.6);
      background: rgba(0, 0, 0, 0.65);
      color: var(--text-main);
      text-align: center;
      text-transform: uppercase;
      font-size: 14px;
      outline: none;
      border-radius: 3px;
    }

    .cw-input:focus {
      border-color: #fff;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
    }

    .cw-input.correct {
      background: rgba(0, 60, 0, 0.8);
      border-color: #3fbf6b;
    }

    .cw-input.wrong {
      background: rgba(80, 0, 0, 0.8);
      border-color: var(--error);
    }

    .cw-buttons {
      text-align: center;
      margin-bottom: 10px;
    }

    .cw-btn {
      border: 1px solid var(--copper);
      background: transparent;
      color: var(--copper-light);
      padding: 5px 14px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 3px;
      margin: 0 4px;
    }

    .cw-btn:hover {
      background: rgba(191, 140, 96, 0.15);
    }

    .cw-message {
      text-align: center;
      font-size: 12px;
      min-height: 16px;
      margin-bottom: 10px;
    }

    .cw-message.ok {
      color: #79d27b;
    }

    .cw-message.err {
      color: var(--error);
    }

    .cw-clues {
      font-size: 13px;
      line-height: 1.4;
    }

    .cw-clues h2 {
      font-size: 14px;
      margin: 6px 0 2px;
      color: var(--copper-light);
    }

    .cw-clues ol {
      margin: 2px 0 6px 16px;
      padding: 0;
    }

    .cw-clues li {
      margin-bottom: 2px;
    }

    @media (max-width: 600px) {
      .cw-wrapper {
        margin: 12px 4px;
        padding: 10px;
      }
      h1 {
        font-size: 18px;
      }
      .cw-board {
        max-width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="cw-wrapper">
    <h1>Zertifikats-Kreuzworträtsel – Level 1</h1>

    <div class="cw-top-bar">
      <button class="cw-toggle active" data-dir="across">Waagrecht</button>
      <button class="cw-toggle" data-dir="down">Senkrecht</button>
    </div>

    <div class="cw-board-wrapper">
      <div class="cw-board">
        <div class="cw-bg"></div>
        <div id="cw-grid" class="cw-grid"></div>
      </div>
    </div>

    <div class="cw-buttons">
      <button id="check-btn" class="cw-btn">Lösung prüfen</button>
      <button id="clear-btn" class="cw-btn">Alles löschen</button>
    </div>

    <div id="cw-message" class="cw-message"></div>

    <div class="cw-clues">
      <h2>Waagrecht</h2>
      <ol id="cw-across"></ol>

      <h2>Senkrecht</h2>
      <ol id="cw-down"></ol>
    </div>
  </div>

  <script>
    // ------------------------------------------------------------
    // KONFIGURATION: HIER NUR WÖRTER + TEXTE ANPASSEN
    // ------------------------------------------------------------
    const GRID_SIZE = 17;

    const WORDS_INPUT = [
      {
        answer: "ASTROLOGIE",
        clue: "Lehre von den Zusammenhängen zwischen Gestirnen und irdischen Ereignissen.",
        direction: "across",
      },
      {
        answer: "CHIRON",
        clue: "Planetoid, der oft mit Wunde und Heilung verbunden wird.",
        direction: "down",
      },
      {
        answer: "ASPEKT",
        clue: "Winkelbeziehung zwischen zwei Planeten.",
        direction: "across",
      },
      {
        answer: "STERNBILD",
        clue: "Worin stehen die Sternbilder in der Nacht?",
        direction: "down",
      },
    ];

    // ------------------------------------------------------------
    // INTERNER ZUSTAND
    // ------------------------------------------------------------
    const gridEl = document.getElementById("cw-grid");
    const acrossListEl = document.getElementById("cw-across");
    const downListEl = document.getElementById("cw-down");
    const msgEl = document.getElementById("cw-message");
    const checkBtn = document.getElementById("check-btn");
    const clearBtn = document.getElementById("clear-btn");
    const toggleButtons = document.querySelectorAll(".cw-toggle");

    let selectedDirection = "across"; // durch die Toggle-Buttons gesteuert
    let placedWords = [];
    let cells = []; // 2D: [row][col] = { cellEl, inputEl, solutions: [], numberEl? }

    let activeWord = null;
    let activeIndexInWord = 0;

    // ------------------------------------------------------------
    // HILFSFUNKTIONEN
    // ------------------------------------------------------------

    function createEmptyGridData(size) {
      const grid = [];
      for (let r = 0; r < size; r++) {
        const row = [];
        for (let c = 0; c < size; c++) {
          row.push({
            char: null, // korrekte Buchstaben (falls Teil eines Wortes)
            words: [],  // welche Wörter laufen hier durch
          });
        }
        grid.push(row);
      }
      return grid;
    }

    // versucht, alle Wörter sinnvoll zu platzieren
    function layoutWords(words) {
      const gridData = createEmptyGridData(GRID_SIZE);

      // längstes Wort zuerst, waagrecht
      const sorted = [...words].sort((a, b) => b.answer.length - a.answer.length);
      const first = sorted[0];
      const middleRow = Math.floor(GRID_SIZE / 2);
      const startCol = Math.floor((GRID_SIZE - first.answer.length) / 2);

      placeWordOnGrid(first, middleRow, startCol, "across", gridData);

      // Rest einbauen
      for (let i = 1; i < sorted.length; i++) {
        const w = sorted[i];
        if (!placeWordWithOverlap(w, gridData)) {
          // Falls GAR kein Platz gefunden wird, wird es übersprungen.
          // Für deine Wortlisten sollte das aber nicht vorkommen.
          console.warn("Konnte Wort nicht platzieren:", w.answer);
        }
      }

      return gridData;
    }

    function placeWordOnGrid(wordDef, row, col, direction, gridData) {
      const answer = wordDef.answer.toUpperCase();
      const positions = [];

      for (let i = 0; i < answer.length; i++) {
        const r = direction === "across" ? row : row + i;
        const c = direction === "across" ? col + i : col;

        gridData[r][c].char = answer[i];
        gridData[r][c].words.push(wordDef);
        positions.push({ row: r, col: c });
      }

      placedWords.push({
        ...wordDef,
        direction,
        row,
        col,
        positions,
        number: null, // später vergeben
      });
    }

    // sucht eine Position für wordDef mit mindestens einem gemeinsamen Buchstaben
    function placeWordWithOverlap(wordDef, gridData) {
      const answer = wordDef.answer.toUpperCase();
      const candidates = [];

      for (const placed of placedWords) {
        const placedAnswer = placed.answer.toUpperCase();

        for (let i = 0; i < answer.length; i++) {
          const ch = answer[i];

          for (let j = 0; j < placedAnswer.length; j++) {
            if (placedAnswer[j] !== ch) continue;

            // Wenn placed across ist, setzen wir neues Wort down und umgekehrt
            if (placed.direction === "across") {
              const row = placed.row;
              const col = placed.col + j;
              const startRow = row - i;
              if (canPlace(answer, startRow, col, "down", gridData)) {
                candidates.push({ row: startRow, col, direction: "down" });
              }
            } else {
              const row = placed.row + j;
              const col = placed.col;
              const startCol = col - i;
              if (canPlace(answer, row, startCol, "across", gridData)) {
                candidates.push({ row, col: startCol, direction: "across" });
              }
            }
          }
        }
      }

      if (candidates.length === 0) {
        return false;
      }

      // Einfach ersten Kandidaten nehmen
      const best = candidates[0];
      placeWordOnGrid(wordDef, best.row, best.col, best.direction, gridData);
      return true;
    }

    function canPlace(answer, startRow, startCol, direction, gridData) {
      if (direction === "across") {
        if (startCol < 0 || startCol + answer.length > GRID_SIZE) return false;
        if (startRow < 0 || startRow >= GRID_SIZE) return false;
      } else {
        if (startRow < 0 || startRow + answer.length > GRID_SIZE) return false;
        if (startCol < 0 || startCol >= GRID_SIZE) return false;
      }

      for (let i = 0; i < answer.length; i++) {
        const r = direction === "across" ? startRow : startRow + i;
        const c = direction === "across" ? startCol + i : startCol;

        const existing = gridData[r][c].char;
        if (existing && existing !== answer[i]) {
          return false;
        }
      }

      return true;
    }

    // Nummern vergeben (klassische Kreuzwortlogik)
    function assignNumbers() {
      let number = 1;
      for (const word of placedWords) {
        const firstPos = word.positions[0];
        const r = firstPos.row;
        const c = firstPos.col;

        let startsWord = false;
        if (word.direction === "across") {
          if (c === 0 || !cells[r][c - 1].solutionChar) {
            startsWord = true;
          }
        } else {
          if (r === 0 || !cells[r - 1][c].solutionChar) {
            startsWord = true;
          }
        }

        if (startsWord) {
          word.number = number++;
        }
      }
    }

    function renderGrid(gridData) {
      gridEl.innerHTML = "";
      cells = [];

      for (let r = 0; r < GRID_SIZE; r++) {
        const rowCells = [];
        for (let c = 0; c < GRID_SIZE; c++) {
          const cellData = gridData[r][c];

          const cellEl = document.createElement("div");
          cellEl.className = "cw-cell";

          const cellObj = {
            row: r,
            col: c,
            cellEl,
            inputEl: null,
            solutionChar: cellData.char || null,
            numberEl: null,
          };

          if (!cellData.char) {
            cellEl.classList.add("empty");
          } else {
            const input = document.createElement("input");
            input.className = "cw-input";
            input.maxLength = 1;
            input.autocomplete = "off";
            input.inputMode = "latin";
            cellEl.appendChild(input);
            cellObj.inputEl = input;

            input.addEventListener("focus", () => {
              setActiveByCell(r, c);
            });

            input.addEventListener("click", () => {
              setActiveByCell(r, c);
            });

            input.addEventListener("keydown", (e) => {
              handleKeyDown(e, cellObj);
            });

            input.addEventListener("input", (e) => {
              handleInput(e, cellObj);
            });
          }

          gridEl.appendChild(cellEl);
          rowCells.push(cellObj);
        }
        cells.push(rowCells);
      }
    }

    function placeNumbersOnGrid() {
      for (const word of placedWords) {
        if (!word.number) continue;
        const firstPos = word.positions[0];
        const cell = cells[firstPos.row][firstPos.col];

        const numEl = document.createElement("div");
        numEl.className = "cw-number";
        numEl.textContent = word.number;
        cell.cellEl.appendChild(numEl);
        cell.numberEl = numEl;
      }
    }

    function renderClues() {
      acrossListEl.innerHTML = "";
      downListEl.innerHTML = "";

      const acrossWords = placedWords
        .filter((w) => w.direction === "across" && w.number !== null)
        .sort((a, b) => a.number - b.number);

      const downWords = placedWords
        .filter((w) => w.direction === "down" && w.number !== null)
        .sort((a, b) => a.number - b.number);

      for (const w of acrossWords) {
        const li = document.createElement("li");
        li.textContent = `${w.number}. ${w.clue}`;
        acrossListEl.appendChild(li);
      }

      for (const w of downWords) {
        const li = document.createElement("li");
        li.textContent = `${w.number}. ${w.clue}`;
        downListEl.appendChild(li);
      }
    }

    // ------------------------------------------------------------
    // AKTIVES WORT / TASTENSTEUERUNG
    // ------------------------------------------------------------

    function setActiveByCell(row, col) {
      const possible = placedWords.filter((w) =>
        w.positions.some((p) => p.row === row && p.col === col)
      );

      if (possible.length === 0) {
        activeWord = null;
        return;
      }

      // Bevorzugt: Wort in der aktuell gewählten Richtung
      let chosen = possible.find((w) => w.direction === selectedDirection);
      if (!chosen) {
        chosen = possible[0];
        selectedDirection = chosen.direction;
        updateDirectionButtons();
      }

      activeWord = chosen;

      // Index innerhalb des Wortes finden
      activeIndexInWord = activeWord.positions.findIndex(
        (p) => p.row === row && p.col === col
      );
    }

    function moveCursor(step) {
      if (!activeWord) return;

      let newIndex = activeIndexInWord + step;
      if (newIndex < 0) newIndex = 0;
      if (newIndex >= activeWord.positions.length)
        newIndex = activeWord.positions.length - 1;

      activeIndexInWord = newIndex;
      const pos = activeWord.positions[activeIndexInWord];
      const cellObj = cells[pos.row][pos.col];
      if (cellObj.inputEl) {
        cellObj.inputEl.focus();
        cellObj.inputEl.select();
      }
    }

    function handleKeyDown(e, cellObj) {
      if (!activeWord) {
        setActiveByCell(cellObj.row, cellObj.col);
      }

      switch (e.key) {
        case "ArrowLeft":
          selectedDirection = "across";
          updateDirectionButtons();
          moveCursor(-1);
          e.preventDefault();
          break;
        case "ArrowRight":
          selectedDirection = "across";
          updateDirectionButtons();
          moveCursor(1);
          e.preventDefault();
          break;
        case "ArrowUp":
          selectedDirection = "down";
          updateDirectionButtons();
          moveCursor(-1);
          e.preventDefault();
          break;
        case "ArrowDown":
          selectedDirection = "down";
          updateDirectionButtons();
          moveCursor(1);
          e.preventDefault();
          break;
        case "Backspace":
          if (cellObj.inputEl.value === "") {
            moveCursor(-1);
          }
          break;
      }
    }

    function handleInput(e, cellObj) {
      const val = e.target.value.toUpperCase().replace(/[^A-ZÄÖÜß]/g, "");
      e.target.value = val;

      if (!activeWord) {
        setActiveByCell(cellObj.row, cellObj.col);
      }

      if (val && activeWord) {
        moveCursor(1);
      }
    }

    // ------------------------------------------------------------
    // AUSWERTUNG / BUTTONS
    // ------------------------------------------------------------

    function clearAll() {
      for (const row of cells) {
        for (const cell of row) {
          if (cell.inputEl) {
            cell.inputEl.value = "";
            cell.inputEl.classList.remove("correct", "wrong");
          }
        }
      }
      msgEl.textContent = "";
      msgEl.className = "cw-message";
    }

    function checkSolution() {
      let allFilled = true;
      let allCorrect = true;

      for (const row of cells) {
        for (const cell of row) {
          if (!cell.inputEl || !cell.solutionChar) continue;
          const val = cell.inputEl.value.toUpperCase();
          if (!val) {
            allFilled = false;
            cell.inputEl.classList.remove("correct", "wrong");
            allCorrect = false;
            continue;
          }
          if (val === cell.solutionChar) {
            cell.inputEl.classList.add("correct");
            cell.inputEl.classList.remove("wrong");
          } else {
            cell.inputEl.classList.add("wrong");
            cell.inputEl.classList.remove("correct");
            allCorrect = false;
          }
        }
      }

      if (!allFilled) {
        msgEl.textContent = "Es sind noch leere Felder vorhanden.";
        msgEl.className = "cw-message err";
      } else if (allCorrect) {
        msgEl.textContent =
          "Perfekt! Alle Antworten sind richtig. Merke dir das Lösungswort für das nächste Level.";
        msgEl.className = "cw-message ok";
      } else {
        msgEl.textContent =
          "Es sind noch Fehler vorhanden. Korrigiere die markierten Felder.";
        msgEl.className = "cw-message err";
      }
    }

    // ------------------------------------------------------------
    // RICHTUNG BUTTONS
    // ------------------------------------------------------------

    function updateDirectionButtons() {
      toggleButtons.forEach((btn) => {
        if (btn.dataset.dir === selectedDirection) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });
    }

    toggleButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        selectedDirection = btn.dataset.dir;
        updateDirectionButtons();
        if (activeWord && activeWord.direction !== selectedDirection) {
          // Richtung gewechselt → aktives Wort auf eins in dieser Richtung an derselben Zelle umlegen
          const pos = activeWord.positions[activeIndexInWord];
          setActiveByCell(pos.row, pos.col);
        }
      });
    });

    checkBtn.addEventListener("click", checkSolution);
    clearBtn.addEventListener("click", clearAll);

    // ------------------------------------------------------------
    // INITIALISIERUNG
    // ------------------------------------------------------------
    (function init() {
      placedWords = [];
      const gridData = layoutWords(WORDS_INPUT);
      renderGrid(gridData);
      assignNumbers();
      placeNumbersOnGrid();
      renderClues();
    })();
  </script>
</body>
</html>
