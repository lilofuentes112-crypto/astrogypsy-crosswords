<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Zertifikats-Kreuzworträtsel – Level 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg-dark: #000000;
      --copper: #bf8c60;
      --copper-light: #f0c8a0;
      --text-main: #f5e7d8;
      --error: #ff6666;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      background: #000;
      color: var(--text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    .cw-wrapper {
      margin: 24px 8px;
      border: 2px solid var(--copper);
      padding: 16px;
      max-width: 900px;
      width: 100%;
      background: #000;
    }

    h1 {
      text-align: center;
      font-size: 20px;
      margin: 0 0 12px;
      color: var(--copper-light);
    }

    .cw-top-bar {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .cw-toggle {
      border: 1px solid var(--copper);
      background: transparent;
      color: var(--copper-light);
      padding: 4px 10px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 3px;
    }

    .cw-toggle.active {
      background: var(--copper);
      color: #000;
    }

    .cw-board-wrapper {
      position: relative;
      width: 100%;
      display: flex;
      justify-content: center;
      margin-bottom: 10px;
    }

    .cw-board {
      position: relative;
      width: 100%;
      max-width: 480px;
      aspect-ratio: 1 / 1;
      border: 2px solid var(--copper);
      overflow: hidden;
    }

    .cw-bg {
      position: absolute;
      inset: 0;
      background-image: url("https://static.wixstatic.com/media/6d3632_8671621dade74457977217105254aadf~mv2.png");
      background-size: cover;
      background-position: center;
      opacity: 0.75;
      pointer-events: none;
      z-index: 0;
    }

    .cw-grid {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: repeat(15, 1fr);
      grid-template-rows: repeat(15, 1fr);
      z-index: 1;
    }

    .cw-cell {
      position: relative;
      border: 1px solid rgba(191, 140, 96, 0.3);
      display: flex;
      justify-content: center;
      align-items: center;
      background: rgba(0, 0, 0, 0.35);
    }

    .cw-cell.empty {
      border: none;
      background: transparent;
    }

    .cw-number {
      position: absolute;
      top: 1px;
      left: 2px;
      font-size: 9px;
      color: var(--copper-light);
      pointer-events: none;
    }

    .cw-input {
      width: 90%;
      height: 90%;
      border: 1px solid rgba(191, 140, 96, 0.6);
      background: rgba(0, 0, 0, 0.65);
      color: var(--text-main);
      text-align: center;
      text-transform: uppercase;
      font-size: 14px;
      outline: none;
      border-radius: 3px;
    }

    .cw-input:focus {
      border-color: #fff;
      box-shadow: 0 0 4px rgba(255, 255, 255, 0.8);
    }

    .cw-input.correct {
      background: rgba(0, 60, 0, 0.8);
      border-color: #3fbf6b;
    }

    .cw-input.wrong {
      background: rgba(80, 0, 0, 0.8);
      border-color: var(--error);
    }

    .cw-buttons {
      text-align: center;
      margin-bottom: 10px;
    }

    .cw-btn {
      border: 1px solid var(--copper);
      background: transparent;
      color: var(--copper-light);
      padding: 5px 14px;
      font-size: 13px;
      cursor: pointer;
      border-radius: 3px;
      margin: 0 4px;
    }

    .cw-btn:hover {
      background: rgba(191, 140, 96, 0.15);
    }

    .cw-message {
      text-align: center;
      font-size: 12px;
      min-height: 16px;
      margin-bottom: 10px;
    }

    .cw-message.ok { color: #79d27b; }
    .cw-message.err { color: var(--error); }

    .cw-clues {
      font-size: 13px;
      line-height: 1.4;
    }

    .cw-clues h2 {
      font-size: 14px;
      margin: 6px 0 2px;
      color: var(--copper-light);
    }

    .cw-clues ul {
      margin: 2px 0 6px 16px;
      padding: 0;
      list-style: none;
    }

    .cw-clues li { margin-bottom: 2px; }

    @media (max-width: 600px) {
      .cw-wrapper {
        margin: 12px 4px;
        padding: 10px;
      }
      h1 { font-size: 18px; }
      .cw-board { max-width: 100%; }
    }
  </style>
</head>
<body>
  <div class="cw-wrapper">
    <h1>Zertifikats-Kreuzworträtsel – Level 1</h1>

    <div class="cw-top-bar">
      <button class="cw-toggle active" data-dir="across">Waagrecht</button>
      <button class="cw-toggle" data-dir="down">Senkrecht</button>
    </div>

    <div class="cw-board-wrapper">
      <div class="cw-board">
        <div class="cw-bg"></div>
        <div id="cw-grid" class="cw-grid"></div>
      </div>
    </div>

    <div class="cw-buttons">
      <button id="check-btn" class="cw-btn">Lösung prüfen</button>
      <button id="clear-btn" class="cw-btn">Alles löschen</button>
    </div>

    <div id="cw-message" class="cw-message"></div>

    <div class="cw-clues">
      <h2>Waagrecht</h2>
      <ul id="cw-across"></ul>

      <h2>Senkrecht</h2>
      <ul id="cw-down"></ul>
    </div>
  </div>

  <script>
    const GRID_SIZE = 15;

    // Feste Definition für Level 1:
    // Koordinaten: row/col 0–14
    const WORDS = [
      {
        number: 1,
        answer: "ASTROLOGIE",
        clue: "Lehre von den Zusammenhängen zwischen Gestirnen und irdischen Ereignissen.",
        direction: "across",
        row: 7,
        col: 3
      },
      {
        number: 1,
        answer: "STERNBILD",
        clue: "Worin stehen die Sternbilder in der Nacht?",
        direction: "down",
        row: 0,
        col: 8
      },
      {
        number: 2,
        answer: "CHIRON",
        clue: "Planetoid, der oft mit Wunde und Heilung verbunden wird.",
        direction: "down",
        row: 4,
        col: 6
      },
      {
        number: 3,
        answer: "ASPEKT",
        clue: "Winkelbeziehung zwischen zwei Planeten.",
        direction: "down",
        row: 2,
        col: 5
      }
    ];

    const gridEl = document.getElementById("cw-grid");
    const acrossListEl = document.getElementById("cw-across");
    const downListEl = document.getElementById("cw-down");
    const msgEl = document.getElementById("cw-message");
    const checkBtn = document.getElementById("check-btn");
    const clearBtn = document.getElementById("clear-btn");
    const toggleButtons = document.querySelectorAll(".cw-toggle");

    let selectedDirection = "across";
    let cells = []; // [row][col] -> { row,col,cellEl,inputEl,solutionChar,numberEl }

    function createEmptyGridData(size) {
      const grid = [];
      for (let r = 0; r < size; r++) {
        const row = [];
        for (let c = 0; c < size; c++) {
          row.push({ char: null, number: null });
        }
        grid.push(row);
      }
      return grid;
    }

    function fillWords(gridData) {
      for (const w of WORDS) {
        const answer = w.answer.toUpperCase();
        for (let i = 0; i < answer.length; i++) {
          const r = w.direction === "across" ? w.row : w.row + i;
          const c = w.direction === "across" ? w.col + i : w.col;

          const cell = gridData[r][c];
          if (cell.char && cell.char !== answer[i]) {
            console.warn("Buchstabenkonflikt bei", r, c);
          } else {
            cell.char = answer[i];
          }
        }

        // Nummer nur auf Startfeld schreiben
        const sr = w.row;
        const sc = w.col;
        if (gridData[sr][sc].number === null) {
          gridData[sr][sc].number = w.number;
        }
      }
    }

    function renderGrid(gridData) {
      gridEl.innerHTML = "";
      cells = [];

      for (let r = 0; r < GRID_SIZE; r++) {
        const rowCells = [];
        for (let c = 0; c < GRID_SIZE; c++) {
          const data = gridData[r][c];
          const cellEl = document.createElement("div");
          cellEl.className = "cw-cell";

          const cellObj = {
            row: r,
            col: c,
            cellEl,
            inputEl: null,
            solutionChar: data.char || null,
            numberEl: null
          };

          if (!data.char) {
            cellEl.classList.add("empty");
          } else {
            const input = document.createElement("input");
            input.className = "cw-input";
            input.maxLength = 1;
            input.autocomplete = "off";
            input.inputMode = "latin";
            cellEl.appendChild(input);
            cellObj.inputEl = input;

            input.addEventListener("keydown", (e) => handleKeyDown(e, cellObj));
            input.addEventListener("input", (e) => handleInput(e, cellObj));
          }

          if (data.number !== null) {
            const numEl = document.createElement("div");
            numEl.className = "cw-number";
            numEl.textContent = data.number;
            cellEl.appendChild(numEl);
            cellObj.numberEl = numEl;
          }

          gridEl.appendChild(cellEl);
          rowCells.push(cellObj);
        }
        cells.push(rowCells);
      }
    }

    function renderClues() {
      acrossListEl.innerHTML = "";
      downListEl.innerHTML = "";

      const across = WORDS
        .filter((w) => w.direction === "across")
        .sort((a, b) => a.number - b.number);
      const down = WORDS
        .filter((w) => w.direction === "down")
        .sort((a, b) => a.number - b.number);

      for (const w of across) {
        const li = document.createElement("li");
        li.textContent = `${w.number}. ${w.clue}`;
        acrossListEl.appendChild(li);
      }

      for (const w of down) {
        const li = document.createElement("li");
        li.textContent = `${w.number}. ${w.clue}`;
        downListEl.appendChild(li);
      }
    }

    function moveFocusFrom(cellObj, dir) {
      let dRow = 0, dCol = 0;
      if (dir === "across") dCol = 1;
      if (dir === "down") dRow = 1;

      let r = cellObj.row;
      let c = cellObj.col;

      while (true) {
        r += dRow;
        c += dCol;
        if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) return;
        const next = cells[r][c];
        if (next && next.inputEl) {
          next.inputEl.focus();
          next.inputEl.select();
          return;
        }
      }
    }

    function moveFocusStep(cellObj, stepDir) {
      let dRow = 0, dCol = 0;
      if (stepDir === "left") dCol = -1;
      if (stepDir === "right") dCol = 1;
      if (stepDir === "up") dRow = -1;
      if (stepDir === "down") dRow = 1;

      let r = cellObj.row;
      let c = cellObj.col;

      while (true) {
        r += dRow;
        c += dCol;
        if (r < 0 || r >= GRID_SIZE || c < 0 || c >= GRID_SIZE) return;
        const next = cells[r][c];
        if (next && next.inputEl) {
          next.inputEl.focus();
          next.inputEl.select();
          return;
        }
      }
    }

    function handleKeyDown(e, cellObj) {
      switch (e.key) {
        case "ArrowLeft":
          selectedDirection = "across";
          updateDirectionButtons();
          moveFocusStep(cellObj, "left");
          e.preventDefault();
          break;
        case "ArrowRight":
          selectedDirection = "across";
          updateDirectionButtons();
          moveFocusStep(cellObj, "right");
          e.preventDefault();
          break;
        case "ArrowUp":
          selectedDirection = "down";
          updateDirectionButtons();
          moveFocusStep(cellObj, "up");
          e.preventDefault();
          break;
        case "ArrowDown":
          selectedDirection = "down";
          updateDirectionButtons();
          moveFocusStep(cellObj, "down");
          e.preventDefault();
          break;
        case "Backspace":
          if (cellObj.inputEl.value === "") {
            if (selectedDirection === "across") {
              moveFocusStep(cellObj, "left");
            } else {
              moveFocusStep(cellObj, "up");
            }
          }
          break;
      }
    }

    function handleInput(e, cellObj) {
      const val = e.target.value.toUpperCase().replace(/[^A-ZÄÖÜß]/g, "");
      e.target.value = val;
      if (val) {
        moveFocusFrom(cellObj, selectedDirection);
      }
    }

    function clearAll() {
      for (const row of cells) {
        for (const cell of row) {
          if (cell.inputEl) {
            cell.inputEl.value = "";
            cell.inputEl.classList.remove("correct", "wrong");
          }
        }
      }
      msgEl.textContent = "";
      msgEl.className = "cw-message";
    }

    function checkSolution() {
      let allFilled = true;
      let allCorrect = true;

      for (const row of cells) {
        for (const cell of row) {
          if (!cell.inputEl || !cell.solutionChar) continue;
          const val = cell.inputEl.value.toUpperCase();
          if (!val) {
            allFilled = false;
            cell.inputEl.classList.remove("correct", "wrong");
            allCorrect = false;
            continue;
          }
          if (val === cell.solutionChar) {
            cell.inputEl.classList.add("correct");
            cell.inputEl.classList.remove("wrong");
          } else {
            cell.inputEl.classList.add("wrong");
            cell.inputEl.classList.remove("correct");
            allCorrect = false;
          }
        }
      }

      if (!allFilled) {
        msgEl.textContent = "Es sind noch leere Felder vorhanden.";
        msgEl.className = "cw-message err";
      } else if (allCorrect) {
        msgEl.textContent =
          "Perfekt! Alle Antworten sind richtig. Merke dir das Lösungswort für das nächste Level.";
        msgEl.className = "cw-message ok";
      } else {
        msgEl.textContent =
          "Es sind noch Fehler vorhanden. Korrigiere die markierten Felder.";
        msgEl.className = "cw-message err";
      }
    }

    function updateDirectionButtons() {
      toggleButtons.forEach((btn) => {
        if (btn.dataset.dir === selectedDirection) {
          btn.classList.add("active");
        } else {
          btn.classList.remove("active");
        }
      });
    }

    toggleButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        selectedDirection = btn.dataset.dir;
        updateDirectionButtons();
      });
    });

    checkBtn.addEventListener("click", checkSolution);
    clearBtn.addEventListener("click", clearAll);

    (function init() {
      const gridData = createEmptyGridData(GRID_SIZE);
      fillWords(gridData);
      renderGrid(gridData);
      renderClues();
    })();
  </script>
</body>
</html>

