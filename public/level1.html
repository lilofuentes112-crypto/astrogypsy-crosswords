<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Zertifikats-Kreuzworträtsel – Level 1</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #000;
      color: #f5e0c0;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
    }
    .cw-wrapper {
      position: relative;
      width: 100%;
      max-width: 600px;
      padding: 16px;
      box-sizing: border-box;
    }
    .cw-background {
      position: absolute;
      inset: 0;
      background-size: cover;
      background-position: center;
      opacity: 0.35; /* Bild etwas deutlicher sichtbar */
      z-index: 0;
    }
    .cw-content {
      position: relative;
      z-index: 1;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid #8c5b2f;
      border-radius: 8px;
      padding: 12px;
      backdrop-filter: blur(2px);
    }
    h1 {
      font-size: 1.3rem;
      margin: 0 0 8px 0;
      text-align: center;
      color: #f8e7c8;
    }
    .cw-grid {
      margin: 12px auto;
      display: grid;
      gap: 1px;
      background: transparent;
      padding: 4px;
      box-sizing: border-box;
    }
    .cw-cell {
      position: relative;
      background: #000;
      width: 100%;
      padding-top: 100%;
      box-sizing: border-box;
      border: 1px solid #8c5b2f;
    }
    .cw-cell-inner {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .cw-cell input {
      width: 90%;
      height: 90%;
      text-align: center;
      font-size: 1rem;
      border: none;
      outline: none;
      background: #111;
      color: #f5e0c0;
    }
    /* LEERE FELDER „AUSBLENDEN“ */
    .cw-cell.blocked {
      background: transparent;
      border: none;
      pointer-events: none;
    }
    .cw-number {
      position: absolute;
      top: 2px;
      left: 3px;
      font-size: 0.6rem;
      color: #d1b08a;
    }
    .cw-clue-list {
      font-size: 0.9rem;
      margin-top: 8px;
    }
    .cw-clue-list h2 {
      font-size: 1rem;
      margin: 8px 0 4px;
    }
    .cw-clue-item {
      margin-bottom: 4px;
    }
    .cw-buttons {
      margin-top: 10px;
      display: flex;
      justify-content: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      background: #8c5b2f;
      border: none;
      padding: 6px 12px;
      color: #fff;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button:hover {
      background: #a66b34;
    }
    .cw-message {
      margin-top: 8px;
      font-size: 0.9rem;
      text-align: center;
    }
    @media (max-width: 480px) {
      h1 {
        font-size: 1.1rem;
      }
      .cw-cell input {
        font-size: 0.85rem;
      }
    }
  </style>
</head>
<body>
  <div class="cw-wrapper">
    <div class="cw-background" id="cw-background"></div>

    <div class="cw-content">
      <h1>Zertifikats-Kreuzworträtsel – Level 1</h1>
      <div id="cw-grid" class="cw-grid"></div>

      <div class="cw-buttons">
        <button id="checkBtn">Lösung prüfen</button>
        <button id="clearBtn">Alles löschen</button>
      </div>
      <div id="cw-message" class="cw-message"></div>

      <div class="cw-clue-list" id="cw-clues"></div>
    </div>
  </div>

  <script>
    /********************************
     * 1. KONFIGURATION FÜR LEVEL 1
     ********************************/

    // HIER DEINE BILD-URL EINTRAGEN:
    // z.B. const BACKGROUND_IMAGE_URL = "https://deine-seite.de/bilder/chiron-ritter.jpg";
    const BACKGROUND_IMAGE_URL = "https://static.wixstatic.com/media/6d3632_8671621dade74457977217105254aadf~mv2.png";

    const WORDS_CONFIG = [
      { answer: "ASTROLOGIE", clue: "Lehre von den Zusammenhängen zwischen Gestirnen und irdischen Ereignissen." },
      { answer: "CHIRON",     clue: "Planetoid, der oft mit Wunde und Heilung verbunden wird." },
      { answer: "ASPEKT",     clue: "Winkelbeziehung zwischen zwei Planeten." },
      { answer: "HIMMEL",     clue: "Worin stehen die Sternbilder in der Nacht?" }
    ];

    const PASSWORD = "WALDFEE";

    const SUCCESS_TEXT_TEMPLATE =
      "Gratuliere! Du hast Level 1 für das Zertifikat geschafft. " +
      "Merke dir das Passwort {PASSWORT} – es ist dein Zugang zu Level 2.";

    const MAX_ROWS = 15;
    const MAX_COLS = 15;

    /********************************
     * 2. HINTERGRUND SETZEN
     ********************************/
    document.getElementById("cw-background").style.backgroundImage =
      BACKGROUND_IMAGE_URL ? `url('${BACKGROUND_IMAGE_URL}')` : "none";

    /********************************
     * 3. HILFSFUNKTIONEN
     ********************************/
    function createEmptyGrid(rows, cols) {
      const grid = [];
      for (let r = 0; r < rows; r++) {
        const row = [];
        for (let c = 0; c < cols; c++) {
          row.push(null);
        }
        grid.push(row);
      }
      return grid;
    }

    function placeWordOnGrid(grid, wordObj) {
      const { row, col, direction, answer } = wordObj;
      for (let i = 0; i < answer.length; i++) {
        const r = direction === "across" ? row : row + i;
        const c = direction === "across" ? col + i : col;
        grid[r][c] = answer[i];
      }
    }

    function canPlace(grid, wordObj) {
      const { row, col, direction, answer } = wordObj;
      for (let i = 0; i < answer.length; i++) {
        const r = direction === "across" ? row : row + i;
        const c = direction === "across" ? col + i : col;
        if (r < 0 || r >= MAX_ROWS || c < 0 || c >= MAX_COLS) return false;
        const existing = grid[r][c];
        if (existing && existing !== answer[i]) return false;
      }
      return true;
    }

    function tryPlaceWithCrossings(grid, word, placedWords, number) {
      const letters = word.answer.split("");
      for (let placed of placedWords) {
        const placedLetters = placed.answer.split("");
        for (let i = 0; i < letters.length; i++) {
          for (let j = 0; j < placedLetters.length; j++) {
            if (letters[i] !== placedLetters[j]) continue;

            if (placed.direction === "across") {
              const row = placed.row - i;
              const col = placed.col + j;
              const candidate = { ...word, row, col, direction: "down", number };
              if (canPlace(grid, candidate)) return candidate;
            }

            if (placed.direction === "down") {
              const row = placed.row + j;
              const col = placed.col - i;
              const candidate = { ...word, row, col, direction: "across", number };
              if (canPlace(grid, candidate)) return candidate;
            }
          }
        }
      }
      return null;
    }

    function tryPlaceAnywhere(grid, word, number) {
      const len = word.answer.length;
      for (let r = 0; r < MAX_ROWS; r++) {
        for (let c = 0; c <= MAX_COLS - len; c++) {
          const candidate = { ...word, row: r, col: c, direction: "across", number };
          if (canPlace(grid, candidate)) return candidate;
        }
      }
      return null;
    }

    function autoPlaceWords(words) {
      const grid = createEmptyGrid(MAX_ROWS, MAX_COLS);
      const placedWords = [];

      const first = {
        ...words[0],
        row: Math.floor(MAX_ROWS / 2),
        col: Math.floor((MAX_COLS - words[0].answer.length) / 2),
        direction: "across",
        number: 1
      };
      if (first.col < 0 || first.col + first.answer.length > MAX_COLS) {
        throw new Error("Erstes Wort ist zu lang für das Gitter.");
      }
      placeWordOnGrid(grid, first);
      placedWords.push(first);

      let numberCounter = 2;

      for (let i = 1; i < words.length; i++) {
        const w = words[i];
        const placed = tryPlaceWithCrossings(grid, w, placedWords, numberCounter);
        if (!placed) {
          const fallback = tryPlaceAnywhere(grid, w, numberCounter);
          if (!fallback) {
            console.warn("Konnte Wort nicht platzieren:", w.answer);
            continue;
          } else {
            placeWordOnGrid(grid, fallback);
            placedWords.push(fallback);
            numberCounter++;
          }
        } else {
          placeWordOnGrid(grid, placed);
          placedWords.push(placed);
          numberCounter++;
        }
      }

      return { grid, rows: MAX_ROWS, cols: MAX_COLS, placedWords };
    }

    /********************************
     * 4. NAVIGATIONSZUSTAND
     ********************************/
    let placedWordsData;
    let solutionGrid;
    let userInputs = [];

    let currentWord = null;
    let lastFocusRow = null;
    let lastFocusCol = null;
    let lastDirections = [];
    let lastDirIndex = 0;

    function getWordsAtCell(row, col) {
      const words = [];
      if (!placedWordsData) return words;

      for (const w of placedWordsData) {
        if (w.direction === "across") {
          if (row === w.row && col >= w.col && col < w.col + w.answer.length) {
            words.push(w);
          }
        } else {
          if (col === w.col && row >= w.row && row < w.row + w.answer.length) {
            words.push(w);
          }
        }
      }
      return words;
    }

    function buildCellsForWord(w) {
      const cells = [];
      for (let i = 0; i < w.answer.length; i++) {
        if (w.direction === "across") {
          cells.push({ row: w.row, col: w.col + i });
        } else {
          cells.push({ row: w.row + i, col: w.col });
        }
      }
      return cells;
    }

    function setCurrentWordForCell(row, col, allowToggle) {
      const words = getWordsAtCell(row, col);
      if (!words.length) {
        currentWord = null;
        return;
      }

      if (
        !allowToggle &&
        currentWord &&
        currentWord.cells.some((c) => c.row === row && c.col === col)
      ) {
        lastFocusRow = row;
        lastFocusCol = col;
        return;
      }

      if (words.length === 1) {
        currentWord = {
          direction: words[0].direction,
          cells: buildCellsForWord(words[0])
        };
        lastDirections = [words[0].direction];
        lastDirIndex = 0;
      } else {
        const directions = words.map((w) => w.direction);

        if (
          allowToggle &&
          lastFocusRow === row &&
          lastFocusCol === col &&
          lastDirections.length
        ) {
          lastDirIndex = (lastDirIndex + 1) % lastDirections.length;
          const dir = lastDirections[lastDirIndex];
          const w = words.find((w) => w.direction === dir) || words[0];
          currentWord = {
            direction: w.direction,
            cells: buildCellsForWord(w)
          };
        } else {
          const preferred =
            words.find((w) => w.direction === "across") || words[0];
          currentWord = {
            direction: preferred.direction,
            cells: buildCellsForWord(preferred)
          };
          lastDirections = directions;
          lastDirIndex = directions.indexOf(preferred.direction);
        }
      }

      lastFocusRow = row;
      lastFocusCol = col;
    }

    function moveFocusToNext(row, col) {
      if (!currentWord) return;
      const idx = currentWord.cells.findIndex(
        (c) => c.row === row && c.col === col
      );
      if (idx === -1) return;
      const next = currentWord.cells[idx + 1];
      if (!next) return;
      const input = userInputs[next.row][next.col];
      if (input) {
        input.focus();
        input.select();
      }
    }

    function moveFocusToPrev(row, col) {
      if (!currentWord) return;
      const idx = currentWord.cells.findIndex(
        (c) => c.row === row && c.col === col
      );
      if (idx <= 0) return;
      const prev = currentWord.cells[idx - 1];
      const input = userInputs[prev.row][prev.col];
      if (input) {
        input.focus();
        input.select();
      }
    }

    /********************************
     * 5. GITTER AUFBAUEN
     ********************************/
    function buildCrossword() {
      const { grid, rows, cols, placedWords } = autoPlaceWords(WORDS_CONFIG);
      solutionGrid = grid;
      placedWordsData = placedWords;

      const gridEl = document.getElementById("cw-grid");
      gridEl.innerHTML = "";
      gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

      userInputs = [];
      for (let r = 0; r < rows; r++) {
        const rowArray = [];
        for (let c = 0; c < cols; c++) {
          const cellValue = grid[r][c];
          const cell = document.createElement("div");
          cell.className = "cw-cell";

          if (!cellValue) {
            cell.classList.add("blocked");
            rowArray.push(null);
          } else {
            const inner = document.createElement("div");
            inner.className = "cw-cell-inner";

            const input = document.createElement("input");
            input.maxLength = 1;
            input.dataset.row = r;
            input.dataset.col = c;

            input.addEventListener("focus", () => {
              const row = parseInt(input.dataset.row, 10);
              const col = parseInt(input.dataset.col, 10);
              setCurrentWordForCell(row, col, false);
            });

            input.addEventListener("click", () => {
              const row = parseInt(input.dataset.row, 10);
              const col = parseInt(input.dataset.col, 10);
              setCurrentWordForCell(row, col, true);
            });

            input.addEventListener("input", (e) => {
              const el = e.target;
              el.value = el.value.toUpperCase().slice(0, 1);

              const row = parseInt(el.dataset.row, 10);
              const col = parseInt(el.dataset.col, 10);

              if (el.value) {
                moveFocusToNext(row, col);
              }
            });

            input.addEventListener("keydown", (e) => {
              const row = parseInt(e.target.dataset.row, 10);
              const col = parseInt(e.target.dataset.col, 10);

              if (e.key === "Enter") {
                e.preventDefault();
                return;
              }

              if (e.key === "Backspace") {
                if (e.target.value) {
                  return;
                }
                e.preventDefault();
                moveFocusToPrev(row, col);
              }
            });

            inner.appendChild(input);
            cell.appendChild(inner);
            rowArray.push(input);
          }

          gridEl.appendChild(cell);
        }
        userInputs.push(rowArray);
      }

      addNumbersAndClues();
    }

    /********************************
     * 6. NUMMERIERUNG UND FRAGEN
     ********************************/
    function addNumbersAndClues() {
      const gridEl = document.getElementById("cw-grid");
      const cells = gridEl.querySelectorAll(".cw-cell");
      const rows = solutionGrid.length;
      const cols = solutionGrid[0].length;

      function getCellElement(r, c) {
        return cells[r * cols + c];
      }

      const cluesEl = document.getElementById("cw-clues");
      cluesEl.innerHTML = "";

      const across = [];
      const down = [];

      placedWordsData.forEach((w) => {
        const { row, col, direction, number, clue } = w;
        const cellEl = getCellElement(row, col);

        let numSpan = cellEl.querySelector(".cw-number");
        if (numSpan) {
          numSpan.textContent += "/" + number;
        } else {
          numSpan = document.createElement("div");
          numSpan.className = "cw-number";
          numSpan.textContent = number;
          cellEl.appendChild(numSpan);
        }

        if (direction === "across") across.push(w);
        else down.push(w);
      });

      if (across.length) {
        const h = document.createElement("h2");
        h.textContent = "Waagrecht";
        cluesEl.appendChild(h);
        across.forEach((w) => {
          const div = document.createElement("div");
          div.className = "cw-clue-item";
          div.textContent = `${w.number}. ${w.clue}`;
          cluesEl.appendChild(div);
        });
      }

      if (down.length) {
        const h = document.createElement("h2");
        h.textContent = "Senkrecht";
        cluesEl.appendChild(h);
        down.forEach((w) => {
          const div = document.createElement("div");
          div.className = "cw-clue-item";
          div.textContent = `${w.number}. ${w.clue}`;
          cluesEl.appendChild(div);
        });
      }
    }

    /********************************
     * 7. PRÜFEN & LÖSCHEN
     ********************************/
    function checkSolution() {
      let allCorrect = true;

      for (let r = 0; r < solutionGrid.length; r++) {
        for (let c = 0; c < solutionGrid[0].length; c++) {
          const sol = solutionGrid[r][c];
          const input = userInputs[r][c];
          if (!sol || !input) continue;

          const val = (input.value || "").toUpperCase();
          if (val !== sol) {
            allCorrect = false;
          }
        }
      }

      const msgEl = document.getElementById("cw-message");

      if (!allCorrect) {
        msgEl.textContent = "Es sind noch Fehler oder leere Felder vorhanden.";
        msgEl.style.color = "#f0a08f";
        return;
      }

      const text = SUCCESS_TEXT_TEMPLATE.replace("{PASSWORT}", PASSWORD);
      msgEl.textContent = text;
      msgEl.style.color = "#8ff08f";
    }

    function clearAll() {
      for (let r = 0; r < userInputs.length; r++) {
        for (let c = 0; c < userInputs[0].length; c++) {
          const input = userInputs[r][c];
          if (input) input.value = "";
        }
      }
      const msgEl = document.getElementById("cw-message");
      msgEl.textContent = "";
    }

    document.getElementById("checkBtn").addEventListener("click", checkSolution);
    document.getElementById("clearBtn").addEventListener("click", clearAll);

    /********************************
     * 8. START
     ********************************/
    buildCrossword();
  </script>
</body>
</html>

